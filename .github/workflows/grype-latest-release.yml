
name: Grype Scan (latest release)

on:
  schedule:
    - cron: "17 5 * * *"   # daily 05:17 UTC
  release:
    types: [published]
  workflow_dispatch: {}

permissions:
  contents: write           # README-Update + Commit
  actions: read

env:
  REPO: TomTonic/rtcompare
  GRYPE_DB_CACHE_DIR: ~/.cache/grype
  TZ: UTC

jobs:
  scan-latest-release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout default branch (for README commit)
        uses: actions/checkout@v4   # Default branch remains working directory
        # Doc: actions/checkout options & defaults  [7](https://github.com/actions/checkout)

      - name: Cache Grype DB
        uses: actions/cache@v4
        with:
          path: ${{ env.GRYPE_DB_CACHE_DIR }}
          # Use a branch-independent cache key so schedule and workflow_dispatch runs share the Grype DB cache
          key: grype-db-${{ runner.os }}-v1
          restore-keys: |
            grype-db-${{ runner.os }}-

      - name: Install grype
        run: |
          curl -sSfL https://get.anchore.io/grype | sudo sh -s -- -b /usr/local/bin
        # Official install variant  [3](https://oss.anchore.com/docs/installation/grype/)

      - name: Capture Grype metadata
        id: meta
        run: |
          set -euo pipefail

          ver_out=$(grype version)
          echo "$ver_out"

          grype_version=$(awk -F': *' '/^Version:/ {print $2; exit}' <<<"$ver_out")
          grype_build_date=$(awk -F': *' '/^BuildDate:/ {print $2; exit}' <<<"$ver_out")

          grype_version=${grype_version:-unknown}
          grype_build_date=${grype_build_date:-unknown}

          echo "grype_version=$grype_version" >> "$GITHUB_OUTPUT"
          echo "grype_build_date=$grype_build_date" >> "$GITHUB_OUTPUT"

      - name: Resolve latest release (REST) & download source tarball
        id: rel
        run: |
          set -euo pipefail

          if [ "${GITHUB_EVENT_NAME}" = "release" ]; then
            tag=$(jq -r '.release.tag_name' "$GITHUB_EVENT_PATH")
            html_url=$(jq -r '.release.html_url' "$GITHUB_EVENT_PATH")
            tarball_url=$(jq -r '.release.tarball_url' "$GITHUB_EVENT_PATH")
          else
            API="https://api.github.com/repos/${REPO}/releases/latest"
            # GitHub REST: /releases/latest  (version header recommended)
            #  -> provides, among others, tag_name, html_url, tarball_url  [1](https://docs.github.com/en/rest/releases)
            json=$(curl -sSL -H "Accept: application/vnd.github+json" \
                            -H "X-GitHub-Api-Version: 2022-11-28" "$API")
            tag=$(jq -r '.tag_name' <<<"$json")
            html_url=$(jq -r '.html_url' <<<"$json")
            tarball_url=$(jq -r '.tarball_url' <<<"$json")
          fi

          if [ -z "${tag}" ] || [ "${tag}" = "null" ]; then
            echo "No release found (404?)." >&2
            exit 1
          fi

          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "html_url=$html_url" >> "$GITHUB_OUTPUT"
          echo "tarball_url=$tarball_url" >> "$GITHUB_OUTPUT"

          # Download + extract the release source archive
          mkdir -p _scan_src
          curl -sSL -H "Accept: application/vnd.github+json" "$tarball_url" \
            | tar -xz -C _scan_src --strip-components=1
          # Tarball/zipball download via API yields redirects to codeload  [2](https://docs.github.com/en/repositories/working-with-files/using-files/downloading-source-code-archives)[8](https://www.baeldung.com/linux/github-download-tarball)
          # curl -L follows redirects  [6](https://stackoverflow.com/questions/46060010/download-github-release-with-curl)

      - name: Run Grype (JSON)
        run: |
          set -euo pipefail
          if grype dir:_scan_src -o json > grype.json; then
            echo "Grype JSON scan completed successfully (no vulnerabilities found)."
          else
            status=$?
            if [ "$status" -eq 1 ]; then
              echo "Grype JSON scan completed with vulnerabilities found (exit code 1), continuing workflow."
            else
              echo "Grype JSON scan failed with exit code $status" >&2
              exit "$status"
            fi
          fi

      - name: Capture Grype DB status
        id: db
        run: |
          set -euo pipefail

          db_out=$(grype db status)
          echo "$db_out"

          db_schema=$(awk -F': *' '/^Schema:/ {print $2; exit}' <<<"$db_out")
          db_built=$(awk -F': *' '/^Built:/ {print $2; exit}' <<<"$db_out")
          db_status=$(awk -F': *' '/^Status:/ {print $2; exit}' <<<"$db_out")

          db_schema=${db_schema:-unknown}
          db_built=${db_built:-unknown}
          db_status=${db_status:-unknown}

          echo "db_schema=$db_schema" >> "$GITHUB_OUTPUT"
          echo "db_built=$db_built" >> "$GITHUB_OUTPUT"
          echo "db_status=$db_status" >> "$GITHUB_OUTPUT"

      - name: Extract severity counts
        id: counts
        run: |
          set -euo pipefail
          
          # Validate grype.json exists
          if [ ! -f grype.json ]; then
            echo "ERROR: grype.json file not found" >&2
            exit 1
          fi
          
          # Validate grype.json is valid JSON
          if ! jq empty grype.json 2>/dev/null; then
            echo "ERROR: grype.json is not valid JSON" >&2
            exit 1
          fi
          
          # Validate grype.json has expected structure (matches field is an array)
          if ! jq -e '.matches | type == "array"' grype.json >/dev/null 2>/dev/null; then
            echo "ERROR: grype.json does not have expected 'matches' array field" >&2
            exit 1
          fi
          
          total=$(jq '.matches | length' grype.json)
          critical=$(jq '[.matches[].vulnerability.severity | select(.=="Critical")] | length' grype.json)
          high=$(jq     '[.matches[].vulnerability.severity | select(.=="High")]     | length' grype.json)
          medium=$(jq   '[.matches[].vulnerability.severity | select(.=="Medium")]   | length' grype.json)
          low=$(jq      '[.matches[].vulnerability.severity | select(.=="Low")]      | length' grype.json)
          negligible=$(jq '[.matches[].vulnerability.severity | select(.=="Negligible")] | length' grype.json)
          echo "total=$total"           >> "$GITHUB_OUTPUT"
          echo "critical=$critical"     >> "$GITHUB_OUTPUT"
          echo "high=$high"             >> "$GITHUB_OUTPUT"
          echo "medium=$medium"         >> "$GITHUB_OUTPUT"
          echo "low=$low"               >> "$GITHUB_OUTPUT"
          echo "negligible=$negligible" >> "$GITHUB_OUTPUT"

      - name: Update README block
        run: |
          set -euo pipefail
          START="<!-- vuln-scan:start -->"
          END="<!-- vuln-scan:end -->"

          SCAN_TIME=$(date +"%Y-%m-%d %H:%M %Z")

          LINE1="✔ Grype scan of release **${{ steps.rel.outputs.tag }}**"
          LINE2="   ├── Vulnerabilities: **${{ steps.counts.outputs.total }}** matches"
          LINE3="   ├── Severity: ${{ steps.counts.outputs.critical }} critical, ${{ steps.counts.outputs.high }} high, ${{ steps.counts.outputs.medium }} medium, ${{ steps.counts.outputs.low }} low, ${{ steps.counts.outputs.negligible }} negligible"
          LINE4="   ├── Tooling: Grype **${{ steps.meta.outputs.grype_version }}** (built ${{ steps.meta.outputs.grype_build_date }})"
          LINE5="   ├── DB: schema **${{ steps.db.outputs.db_schema }}**, built **${{ steps.db.outputs.db_built }}**, status **${{ steps.db.outputs.db_status }}**"
          LINE6="   └── Scan time: **${SCAN_TIME}**"
          LINE7="_Source: ${{ steps.rel.outputs.html_url }}_"

          NEW_BLOCK="${START}\n${LINE1}\n${LINE2}\n${LINE3}\n${LINE4}\n${LINE5}\n${LINE6}\n${LINE7}\n${END}"

          awk -v start="$START" -v end="$END" -v repl="$NEW_BLOCK" '
            BEGIN{found=0}
            { if ($0==start){print repl; inblock=1; found=1}
              else if ($0==end){inblock=0}
              else if (!inblock){print}
            }
            END{ if (found==0){ print "ERROR: markers not found" > "/dev/stderr"; exit 1 } }
          ' README.md > README.tmp && mv README.tmp README.md

      - name: Commit and push if changed
        run: |
          if git diff --quiet -- README.md; then
            echo "No README changes."
          else
            git config user.name  "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add README.md
            git commit -m "chore(security): grype scan for latest release ${{ steps.rel.outputs.tag }} [skip ci]"
            git push
          fi
