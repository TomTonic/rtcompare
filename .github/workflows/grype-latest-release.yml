
name: Grype Scan (latest release)

on:
  schedule:
    - cron: "53 6 * * *"   # daily 06:53 UTC - after Grype DB update (approx 06:15 UTC)
  release:
    types: [published]
  workflow_dispatch: {}

permissions:
  contents: write           # README-Update + Commit

env:
  REPO: TomTonic/rtcompare
  GRYPE_DB_CACHE_DIR: ~/.cache/grype
  TZ: UTC

jobs:
  scan-latest-release:
    runs-on: ubuntu-latest

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit
  
      - name: Checkout default branch (for README commit)
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Cache Grype DB
        uses: actions/cache@v5
        with:
          path: ${{ env.GRYPE_DB_CACHE_DIR }}
          # Use a branch-independent cache key so schedule and workflow_dispatch runs share the Grype DB cache
          key: grype-db-${{ runner.os }}-v1
          restore-keys: |
            grype-db-${{ runner.os }}-

      - name: Install grype
        run: |
          curl -sSfL https://get.anchore.io/grype | sudo sh -s -- -b /usr/local/bin
        # Official install variant (https://oss.anchore.com/docs/installation/grype/)

      - name: Capture Grype metadata
        id: meta
        run: |
          set -euo pipefail

          ver_out=$(grype version)
          echo "$ver_out"

          # NOTE: Don't split on ':' because timestamps contain ':' too.
          grype_version=$(sed -nE 's/^Version:[[:space:]]*//p' <<<"$ver_out" | head -n1)
          grype_build_date=$(sed -nE 's/^BuildDate:[[:space:]]*//p' <<<"$ver_out" | head -n1)

          grype_version=${grype_version:-unknown}
          grype_build_date=${grype_build_date:-unknown}

          echo "grype_version=$grype_version" >> "$GITHUB_OUTPUT"
          echo "grype_build_date=$grype_build_date" >> "$GITHUB_OUTPUT"

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version-file: 'go.mod'

      - name: Resolve latest release (REST) & download source tarball
        id: rel
        run: |
          set -euo pipefail

          if [ "${GITHUB_EVENT_NAME}" = "release" ]; then
            tag=$(jq -r '.release.tag_name' "$GITHUB_EVENT_PATH")
            html_url=$(jq -r '.release.html_url' "$GITHUB_EVENT_PATH")
            tarball_url=$(jq -r '.release.tarball_url' "$GITHUB_EVENT_PATH")
          else
            API="https://api.github.com/repos/${REPO}/releases/latest"
            # GitHub REST: /releases/latest  (version header recommended)
            #  -> provides, among others, tag_name, html_url, tarball_url  [1](https://docs.github.com/en/rest/releases)
            
            # Capture both HTTP status code and response body
            response=$(curl -sSL -w "\n%{http_code}" \
                            -H "Accept: application/vnd.github+json" \
                            -H "X-GitHub-Api-Version: 2022-11-28" "$API")
            
            # Extract status code (last line) and body (everything else)
            http_code=$(echo "$response" | tail -n1)
            json=$(echo "$response" | sed '$d')
            
            # Check HTTP status code
            if [ "$http_code" != "200" ]; then
              echo "Error: GitHub API returned HTTP $http_code for $API" >&2
              if [ "$http_code" = "404" ]; then
                echo "No releases found for repository ${REPO}. Please create a release first." >&2
              fi
              exit 1
            fi
            
            # Validate JSON response before parsing
            if ! echo "$json" | jq empty 2>/dev/null; then
              echo "Error: Invalid JSON response from GitHub API" >&2
              echo "Response: $json" >&2
              exit 1
            fi
            
            tag=$(jq -r '.tag_name' <<<"$json")
            html_url=$(jq -r '.html_url' <<<"$json")
            tarball_url=$(jq -r '.tarball_url' <<<"$json")
          fi

          if [ -z "${tag}" ] || [ "${tag}" = "null" ]; then
            echo "Error: No release tag found in API response or event payload." >&2
            exit 1
          fi

          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "html_url=$html_url" >> "$GITHUB_OUTPUT"
          echo "tarball_url=$tarball_url" >> "$GITHUB_OUTPUT"

          # Download + extract the release source archive
          mkdir -p _scan_src
          curl -sSL -H "Accept: application/vnd.github+json" "$tarball_url" \
            | tar -xz -C _scan_src --strip-components=1
          # Tarball/zipball download via API yields redirects to codeload  [2](https://docs.github.com/en/repositories/working-with-files/using-files/downloading-source-code-archives)[8](https://www.baeldung.com/linux/github-download-tarball)
          # curl -L follows redirects  [6](https://stackoverflow.com/questions/46060010/download-github-release-with-curl)

      - name: Download Go module dependencies
        working-directory: _scan_src
        run: |
          set -euo pipefail
          go mod download
          go mod verify
          # Compile all packages in the module (not just the example) to ensure dependencies for the whole repo are resolved.
          go build ./...

      - name: Run Grype on Go module source tree (JSON)
        working-directory: _scan_src
        run: |
          set -euo pipefail
          # Scan the module source tree (go.mod/go.sum + source), not a single binary.
          if grype dir:. -o json > ../grype.json; then
            echo "Grype JSON scan completed successfully (no vulnerabilities found)."
          else
            status=$?
            if [ "$status" -eq 1 ]; then
              echo "Grype JSON scan completed with vulnerabilities found (exit code 1), continuing workflow."
            else
              echo "Grype JSON scan failed with exit code $status" >&2
              exit "$status"
            fi
          fi

      - name: Capture Grype DB status
        id: db
        run: |
          set -euo pipefail

          db_out=$(grype db status)
          echo "$db_out"

          # NOTE: Don't split on ':' because timestamps contain ':' too.
          db_schema=$(sed -nE 's/^Schema:[[:space:]]*//p' <<<"$db_out" | head -n1)
          db_built=$(sed -nE 's/^Built:[[:space:]]*//p' <<<"$db_out" | head -n1)
          db_status=$(sed -nE 's/^Status:[[:space:]]*//p' <<<"$db_out" | head -n1)

          db_schema=${db_schema:-unknown}
          db_built=${db_built:-unknown}
          db_status=${db_status:-unknown}

          echo "db_schema=$db_schema" >> "$GITHUB_OUTPUT"
          echo "db_built=$db_built" >> "$GITHUB_OUTPUT"
          echo "db_status=$db_status" >> "$GITHUB_OUTPUT"

      - name: Extract severity counts
        id: counts
        run: |
          set -euo pipefail
          
          # Validate grype.json exists
          if [ ! -f grype.json ]; then
            echo "ERROR: grype.json file not found" >&2
            exit 1
          fi
          
          # Validate grype.json is valid JSON
          if ! jq empty grype.json 2>/dev/null; then
            echo "ERROR: grype.json is not valid JSON" >&2
            exit 1
          fi
          
          # Validate grype.json has expected structure (matches field is an array)
          if ! jq -e '.matches | type == "array"' grype.json 2>/dev/null; then
            echo "ERROR: grype.json does not have expected 'matches' array field" >&2
            exit 1
          fi
          
          total=$(jq '.matches | length' grype.json)
          critical=$(jq '[.matches[].vulnerability.severity | select(.=="Critical")] | length' grype.json)
          high=$(jq     '[.matches[].vulnerability.severity | select(.=="High")]     | length' grype.json)
          medium=$(jq   '[.matches[].vulnerability.severity | select(.=="Medium")]   | length' grype.json)
          low=$(jq      '[.matches[].vulnerability.severity | select(.=="Low")]      | length' grype.json)
          negligible=$(jq '[.matches[].vulnerability.severity | select(.=="Negligible")] | length' grype.json)
          echo "total=$total"           >> "$GITHUB_OUTPUT"
          echo "critical=$critical"     >> "$GITHUB_OUTPUT"
          echo "high=$high"             >> "$GITHUB_OUTPUT"
          echo "medium=$medium"         >> "$GITHUB_OUTPUT"
          echo "low=$low"               >> "$GITHUB_OUTPUT"
          echo "negligible=$negligible" >> "$GITHUB_OUTPUT"

      - name: Update README block
        run: |
          set -euo pipefail
          START="<!-- vuln-scan:start -->"
          END="<!-- vuln-scan:end -->"

          RELEASE_TAG="${{ steps.rel.outputs.tag }}"
          RELEASE_URL="${{ steps.rel.outputs.html_url }}"

          GRYPE_VERSION="${{ steps.meta.outputs.grype_version }}"
          if [[ "$GRYPE_VERSION" == v* ]]; then
            GRYPE_VERSION_TAG="$GRYPE_VERSION"
          else
            GRYPE_VERSION_TAG="v$GRYPE_VERSION"
          fi
          GRYPE_URL="https://github.com/anchore/grype/releases/tag/${GRYPE_VERSION_TAG}"

          # A small, stable-ish Grype logo (from upstream README).
          GRYPE_LOGO_HTML='<img src="https://user-images.githubusercontent.com/5199289/136855393-d0a9eef9-ccf1-4e2b-9d7c-7aad16a567e5.png" width="16" height="24" alt="grype logo" />'

          LINE1="Daily supply chain vulnerability scan of [rtcompare ${RELEASE_TAG}](${RELEASE_URL}): **${{ steps.counts.outputs.total }} CVE's** (${{ steps.counts.outputs.critical }} critical, ${{ steps.counts.outputs.high }} high, ${{ steps.counts.outputs.medium }} medium, ${{ steps.counts.outputs.low }} low severity). Used [grype version ${GRYPE_VERSION}](${GRYPE_URL}) with DB schema ${{ steps.db.outputs.db_schema }}, built ${{ steps.db.outputs.db_built }}."

          NEW_BLOCK="${START}\n${LINE1}\n${END}"

          awk -v start="$START" -v end="$END" -v repl="$NEW_BLOCK" '
            BEGIN{found=0; inblock=0}
            {
              line = $0
              # Trim leading and trailing spaces/tabs before comparing to markers
              gsub(/^[ \t]+|[ \t]+$/, "", line)

              if (line == start) {
                print repl
                inblock = 1
                found = 1
              } else if (line == end) {
                inblock = 0
              } else if (!inblock) {
                print $0
              }
            }
            END{
              if (found==0){
                print "ERROR: markers not found" > "/dev/stderr"
                exit 1
              }
            }
          ' README.md > README.tmp && mv README.tmp README.md

      - name: Commit and push if changed
        run: |
          if git diff --quiet -- README.md; then
            echo "No README changes."
          else
            git config user.name  "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add README.md
            git commit -m "Automated CVE scan of release ${{ steps.rel.outputs.tag }}"
            git push
          fi
